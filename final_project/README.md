# 用C++設計一個 HackCPU 的組譯器

## 執行

$ `g++ myasm.cpp`
產生執行檔 a.exe

需要先下載範例[sum.asm](https://github.com/KimLinTW/co111a/blob/main/final_project/sum.asm)

$ `.\a.exe sum`

### 輸出

```
============= PASS1 ================
00:@10
01:D=A
02:@0
03:M=D
04:@i
05:M=1
06:@sum
07:M=0
08:(LOOP)
symbol:LOOP address=8
08:@i
09:D=M
10:@R0
11:D=D-M
12:@STOP
13:D;JGT
14:@i
15:D=M
16:@sum
17:M=D+M
18:@i
19:M=M+1
20:@LOOP
21:0;JMP
22:(STOP)
symbol:STOP address=22
22:@sum
23:D=M
24:@R1
25:M=D
============= PASS2 ================
00: @10                 0000000000001010 000a
01: D=A                 1110110000010000 ec10
02: @0                  0000000000000000 0000
03: M=D                 1110001100001000 e308
04: @i                  0000000000010000 0010
05: M=1                 1110111111001000 efc8
06: @sum                0000000000010001 0011
07: M=0                 1110101010001000 ea88 
(LOOP)
08: @i                  0000000000010000 0010
09: D=M                 1111110000010000 fc10
0A: @R0                 0000000000000000 0000
0B: D=D-M               1111010011010000 f4d0
0C: @STOP               0000000000010110 0016
0D: D;JGT               1110001100000001 e301
0E: @i                  0000000000010000 0010
0F: D=M                 1111110000010000 fc10
10: @sum                0000000000010001 0011
11: M=D+M               1111000010001000 f088
12: @i                  0000000000010000 0010
13: M=M+1               1111110111001000 fdc8
14: @LOOP               0000000000001000 0008
15: 0;JMP               1110101010000111 ea87
(STOP)
16: @sum                0000000000010001 0011 
17: D=M                 1111110000010000 fc10
18: @R1                 0000000000000001 0001
19: M=D                 1110001100001000 e308
```

---

輸入以 sum.asm 為例，將輸出分成 pass1、pass2 兩部分，分別對應到 程式中的 pass1 -> parse1 及 pass2 -> parse2

### pass1

以 "行" 為單位讀取 sum.asm，並把每一行丟給 parse1函數 處理

#### parse1

1. 清除.asm中的註解及空行(使用regex) 並以十進制從0開始給每一行編號
2. 紀錄符號(如:LOOP、STOP)位置到 symMap變數 中

---

### pass2

以 "行" 為單位讀取 sum.asm，並把每一行丟給 parse2函數 處理
這邊的 parse2 需要將結果寫入 sum.hack 及 sum.bin 中，所以需要額外傳入 ofstream.rdbuf() 類型的物件
透過這個物件可以直接把`cout << ... ;`的結果，如同印在螢幕上直接寫入檔案，配合類似`cout << hex`的語法在不同進位間轉換非常方便

#### parse2

這部分是 parse1 的擴充，所以以下指紀錄相較於 parse1 新增及修改的功能

##### 新增

1. 先判斷(直接檢查是否有'@'的字樣)每一行輸入為A指令還是C指令，再轉成對應的2進位輸出給 sum.hack 及螢幕輸出
2. 把上一步的結果再轉換成16進位，以2進制寫入 sum.bin 並輸出到螢幕上(若要以二進制寫入檔案就無法使用`cout << ...;`的語法寫入，必須使用`ofstream.write()`)

##### 修改

1. 行號改以16進位表示(在 parse1 中為10進位)

---

### 輸出.hack檔

```=
0000000000001010
1110110000010000
0000000000000000
1110001100001000
0000000000010000
1110111111001000
0000000000010001
1110101010001000
0000000000010000
1111110000010000
0000000000000000
1111010011010000
0000000000010110
1110001100000001
0000000000010000
1111110000010000
0000000000010001
1111000010001000
0000000000010000
1111110111001000
0000000000001000
1110101010000111
0000000000010001
1111110000010000
0000000000000001
1110001100001000

```

### 輸出.bin檔

![sum.bin](https://i.imgur.com/kiJiAmK.png)

## 參考部分

主要理解完老師的程式後，以C++的風格(ex: C語言的fopen -> C++的i/ofstream)重寫一遍，並盡可能模仿老師程式的輸出(ex: 分成pass1、2)
所以在整個程式的邏輯上算是參考老師的程式，而為了達到相同的目的我可能使用不同的方法(ex: 去除sum.asm中的註解 我使用regex)
